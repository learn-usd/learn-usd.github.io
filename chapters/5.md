# 5. Rendering an OpenUSD Scene

This chapter covers
- Setting up a scene ready for rendering
- Exploring how to get the most out of lighting settings
- Understanding how cameras work in OpenUSD
- Achieving an end result by rendering images from your scene


```{figure} ./images/5/image10.png
:label: figure-5-1
:alt: title statue
:align: center

The scene we will create to learn about lighting, cameras and rendering in OpenUSD. It contains three .usd objects, a figure and a base which together form a statue, and a backdrop.
```

We created some objects on our stages and referenced other objects to populate our scenes, but you may have noticed that they still look a little flat and unrealistic, even those that have well-made materials added. Further, you may have noticed as you move your viewpoint around the scene that certain angles work better to show off the model, enhancing its appearance and offering a clearer view of the most important details. These are both issues to consider before you reach the final step of rendering an image or animation from your creation and this requires some aesthetic choices.

The solution to the first problem is the addition of some thoughtfully chosen and well-placed lighting that can add depth and atmosphere to a scene, enhancing the fact that they’re three dimensional by highlighting the shape and form of your meshes. Done well, lighting can transform your scene from a lifeless sketch where everything feels a bit like plastic, into anything from a professional looking studio shot, an exterior scene bathed in dawn light, or even a fantastical movie still with magical glowing orbs floating around. If your scene looks dull or unnatural, lighting is your friend.

Once the scene is lit, it's time to consider the second problem, the point of view (POV) of the viewer. It’s time to start playing the role of a photographer. Whether your aim is to render a 2D image from your scene or you are building a 3D environment that is intended to be rendered and experienced in real-time, such as a digital twin, a VR/AR application, or a game, then you will need to establish a viewpoint from which to capture the scene. This is achieved by placing a camera on the stage. 

Astute decisions with your camera will go a long way towards achieving the look and feel you are aiming for. Do you want the scene to look like a crisp, clear diagram of an accurate engineering model, are you hoping to create a portrait with a strong focus on the subject and gently blurred background, or do you want your 3D models to loom towards the viewer with a highly exaggerated perspective? Much like lighting, the camera placement and choice of settings will have a profound effect on the quality, feel and impact of the final rendered image or the immersive experience. 

Let’s explore the process of setting up and rendering an OpenUSD scene. Initially, we will use skills learned in earlier chapters, such as importing, creating and transforming prims to create a simple scene containing a statue and a background.

Next, we’ll move on to understanding lighting types and properties, where we’ll explore the nuances of different lighting techniques, including positioning, intensity, and color settings, to bring your scene to life with realistic and professional illumination. 

Having lit our stage, we will then learn how to harness camera settings and provide guidance on configuring various camera parameters to achieve the desired framing and perspective for your scene. 

Then finally, a section on rendering your stage will tie all of these elements together, demonstrating how to use Blender or USD Composer to produce high-quality visual outputs. By the end of this chapter, you will have a solid understanding of how to leverage Python scripts to control the most fundamental aspects of scene rendering with OpenUSD. {numref}`figure-5-1` shows a render from the scene we will be building.

You have an opportunity to build on the skills you learned earlier by setting up the scene using the code in the {ref}`set-scene` and referencing the objects we have provided.

:::{note}
 Please be sure that you already have downloaded all folders and assets from our github repository here: https://github.com/learn-usd/learn-usd.github.io/tree/main/code_and_assets/Ch05 and will have the relevant folder in your chosen location. 

This download will provide you with all of the assets you require to complete this chapter.
:::

(set-scene)=
## 5.1 Setting Up the Scene
Let’s start off this process by enhancing some of the techniques we learned in previous chapters. We’re going to create a new stage and populate it by importing some .usd objects, i.e, a figure.usd, base.usd, and a backdrop.usd. This can serve as a revision of skills learned in previous chapters whilst also setting up the scene for the rest of the chapter.

Before we begin, remember our discussion in [Chapter 2](./2.md) about the importance of considering the best location for the files and being mindful of your directory structures when choosing where to save files. We recommend using the following directory structure for the statue scene we're about to create and ensuring that you have set `/Ch05` as your working directory:

```
/Ch05
├── Assets
│   ├── textures
│   │   └── <All Texture Files>
│   ├── Backdrop.usd
│   ├── Base.usd
│   └── Figure.usd
└── statue.usd
```

Using the structure above will allow you to move the ‘Ch05’ folder anywhere without breaking the references contained in `statue.usd`, as all those references are contained within the root directory.

On the stage we are about to create, as it is unlikely that you would want to separate the figure from the base it is good practice to arrange the referenced figure.usd and base.usd so that they are children of one Xform, named ‘Statue’. That way if you ever need to move the statue to another position on the stage, you can do so by manipulating the parent Xform of the figure and the base, rather than the figure and base independently:
```python
from pxr import Usd, Sdf, UsdGeom, Gf

stage = Usd.Stage.CreateNew("statue.usd")

# Define the ‘Statue’ Xform
statue = UsdGeom.Xform.Define(stage, '/World/Statue')    

# Define 'Figure' under 'Statue' replace with your figure.usd path, example:  "./Assets/Figure.usd"
figure = UsdGeom.Xform.Define(stage, '/World/Statue/Figure')    
figure_references: Usd.References = figure.GetPrim().GetReferences()
figure_references.AddReference(
	assetPath= <your file path to figure.usd ex: "./Assets/Figure.usd">
)

# Define 'Base' under 'Statue' replace with your base.usd path, example:  "./Assets/Base.usd"
base = UsdGeom.Xform.Define(stage, '/World/Statue/Base')    
base_references: Usd.References = base.GetPrim().GetReferences()
base_references.AddReference(
	assetPath= <your file path to base.usd ex: "./Assets/Base.usd">
)

backdrop = UsdGeom.Xform.Define(stage, '/World/Backdrop')    
backdrop_references: Usd.References = backdrop.GetPrim().GetReferences()
backdrop_references.AddReference(
	assetPath= <your file path to backdrop.usd ex: "./Assets/Backdrop.usd">
)

stage.Save()

```
After saving the stage, you should have a scene that contains a backdrop, and a statue, which consists of the figure and the base. However, depending on your chosen viewer, you may find that the stage is very dark, so let’s move on to adding some lighting.

## 5.2 Mastering Lighting

Lighting is a fundamental aspect of 3D scene creation, as it can dramatically influence the mood, depth, and realism of your environment. Let’s delve into the process of creating and positioning lights using OpenUSD programming. We'll explore various basic lighting types and understand when and why to use different lighting methods. Additionally, we'll first explain how to set light variables programmatically. Then we'll show you how to improve your scene with realistic lighting by using HDR or .exr textures, which replicate environmental lighting and provide backgrounds for your images. By mastering these techniques, you'll be able to craft visually compelling scenes that evoke the atmosphere or style that you are trying to create.

It is often useful to be able to turn lights on and off when building a 3D scene. For this reason, we’ll start this section with an introduction to hiding and showing prims. This is applicable to any prim on your stage but is often used to set the visibility of light prims.

### 5.2.1 Setting the Visibility of Prims 
The following code listings will define custom functions that can be used to toggle the visibility of any prim on any stage. They will be used later in this section to hide some of the lights on our Statue stage. Remember that custom functions are not retained if the command terminal is closed or refreshed, so you may need to redefine these if you are unable to complete the code in this chapter in one session.

```{code} python
:label: code-5-1
:caption: Make a Prim Invisible

def hide_prim(stage: Usd.Stage, prim_path: str):
    """
	Hide a prim
	::params:
    	stage (Usd.Stage): The USD Stage
    	prim_path (string): The prim path of the prim to make invisible
    """
    # Get the prim at the prim path
    prim = stage.GetPrimAtPath(prim_path)    
    # Get the prim's visibility attribute
    visibility_attribute = prim.GetAttribute("visibility")   
    if visibility_attribute:
        visibility_attribute.Set("invisible") # Set the attribute value into "invisible"

```
To make a prim visible again, we can use the following code that defines a function, `show_prim`, which sets the prim’s visibility attribute to "inherited", meaning it will follow the visibility state of its parent prim. This method is particularly helpful in complex hierarchical scenes, as it maintains consistency and simplifies scene management by reducing the need for multiple manual adjustments of individual prims. It can help to manage changes more efficiently, ensuring that updates propagate through the hierarchy without individual modifications.

```{code} python
:label: code-5-2
:caption: Make a Prim Visible

def show_prim(stage: Usd.Stage, prim_path: str):
    """
    Show a prim
    ::params:
        stage (Usd.Stage): The USD Stage
        prim_path (string): The prim path of the prim to make visible
    """
    prim = stage.GetPrimAtPath(prim_path)
    visibility_attribute = prim.GetAttribute("visibility")
    if visibility_attribute:
        visibility_attribute.Set("inherited") # Set the attribute value into "inherited". If the parent prim is visible, the prim will be shown
```
Later in this section we will use these techniques to make prims invisible and switch lights off on our stage. First, let’s start adding some lights to illuminate the statue.

### 5.2.2 Creating Lights
With your stage now set up and populated, it is time to beautify it with some carefully placed illumination. First, consider what type of lighting will be required to achieve the look and style you are aiming for. For example, if you are trying to create the feel of a professional studio shot, you might decide to use the three-point lighting system. (This is the look we’re going for in our Statue scene, so more on that in {ref}`three-point-lighting`). If, on the other hand, you are trying to recreate the feel of flash photography, you may only need a single, bright, directional light positioned very close to the camera to simulate a camera mounted flash. Perhaps instead, you are trying to create a natural outdoor feel in your scene, in which case you will want the feel of distant light coming from one direction, like a midday sun, mixed with more diffuse light coming from all other parts of the sky. In this latter case, you would utilize OpenUSD’s `Distant` or `Dome` lights.

Here is a brief summary of each of the six types of light that are available in OpenUSD.

- **Rect Light**: Emits light from a rectangular area, creating broad and soft lighting. Perfect for simulating large light sources such as windows, softboxes, or other panel lights.
- **Disk Light**: Emits light from a circular disk area, providing softer and more diffused illumination compared to a point light. Ideal for simulating area lights like LED panels or ring lights.
- **Sphere Light**: Emits light from a spherical area. It can be configured to behave like a point light, emitting light uniformly in all directions from a single point, so is often used to simulate an incandescent bulb.
-**Cylinder Light**: Emits light in a cylindrical shape, often used to simulate tube lights or elongated light sources.
- **Distant Light**: Represents light coming from a specific direction, simulating sunlight or other distant light sources. It uniformly affects all objects, regardless of their position.
- **Dome Light**: Encompasses the entire scene with light, simulating the effect of a sky or environmental lighting. Often uses HDR images as texture to provide realistic and ambient lighting, and background scenery.

{ref}`figure-5-2` shows the four types of ‘area’ light that have a physical presence on the stage, a specified size, and can be moved around to alter their effect on the scene. The two additional types of light, the distant and dome lights, do not occupy a space on the stage, but cast light onto it from a distance. These latter two can only be rotated to alter the angle of light on the stage.

```{figure} ./images/5/image20.png
:label: figure-5-2
:alt: light types
:align: center

OpenUSD Light Types: Cylinder (3D, tubular), Disk (2D, circular), Rectangle (2D, area illumination), and Sphere (3D spherical, radiant light).
```

Next, we’ll create one of each type of light on our stage. As we do so, we’ll explore some universal APIs that apply to any type of light on your stage, then examine each type of light individually to understand the APIs that are specific to that type, for example, the cylinder light has both a radius and length setting, whereas a disc light has only a radius setting as it is a flat, 2D source of light.

To add lights into the stage, first we need to load the `UsdLux` package, which provides a representation for lights and related components. We’ll also import the Gf module to enable vectors for modifying the light’s transforms and other properties:
```python
from pxr import UsdLux, Gf
```

Let's define an Xfrom prim named 'Lights', which will serve as the parent prim for all the lights we will add later, then add one rectangular light source:
```python
rect_light = UsdLux.RectLight.Define(stage, "/World/Lights/RectLight")   
```

Next we’ll move the Rect light away from its default position at the World Origin to a position right and front of the statue, then rotate it by 45 degrees on the y axis. To do this, you can use the `AddTranslateOp` and `AddRotateXYZOp` APIs to modify the light's location, and rotate the light around its X, Y, and Z axes:
```python
rect_light.AddTranslateOp().Set(Gf.Vec3d(100, 100, 200))
rect_light.AddRotateXYZOp().Set(Gf.Vec3d(0, 45, 0))
```

Remember, if you decide you want to move the light again, you do it by modifying the existing translate op with the `translate_op.Set()` method, or clear it completely with `ClearXformOpOrder()`.

:::{note}
It is not advisable to use the `AddScaleOp()` to manipulate the size of lights, as this introduces difficulties with light sampling and integration. Instead, each light can be resized with its own specific attributes, such as `width`, `height` or `radius`, etc.
:::

As important as a light’s location is the intensity of its illumination and the color of light it gives off. These properties are set using the `CreateIntensityAttr()` and the `CreateColorAttr()`, respectively. These two APIs are commonly used together to define the overall appearance of a light source in OpenUSD. Let's apply them to our Rect light:

**CreateIntensityAttr**: This API is used to set the intensity or brightness of a light source. It creates an intensity attribute for the light, which can be specified as a scalar value (e.g., a float). 
```python
rect_light.CreateIntensityAttr(30000)
```
**CreateColorAttr**: This API is used to set the color of a light source. It creates a color attribute for the light, which can be specified as a RGB value. Here we will set the color to white by using the values (1, 1, 1):
```python
rect_light.CreateColorAttr(Gf.Vec3f(1, 1, 1))  # RGB (1, 1, 1) defines a white color
```
You can use the above commands to affect the Rect light's hue, saturation, and brightness on the stage. 

The above APIs are applicable for all lights. However, some of the APIs are only applicable for a certain type of lights, so next we'll look more specifically at each type of light. As we go through them, we’ll add each one to the stage and manipulate their transforms and properties, so that you can observe their effects.

:::{warning}
At present, Blender's USD implementation has limited support for non-standard light types. These limitations are gradually being addressed by Blender. All subsequent activities in this book will make use of those light types that are supported in Blender. However, below we will introduce all of the non-standard light types that are available to users of other USD viewers.
:::

Remember, if you are using Blender and you want to view the lights as you add them, you will need to run a `stage.Save()` command, reimport the .usd file in its new state, and change the viewport shading to Render mode.

The following four light types will translate properly from USD into Blender.

#### Rect Light

The Rect light is a 2D flat plane that offers a wide source of light from one of its surfaces, giving soft, natural shadowing. They are suitable for areas that require uniform, wide light distribution, such as under cabinet lighting or to replicate windows or a photographer’s soft box diffuser. You can define the height and width to specify its size.

We've already created, translated, and set the Rect lights intensity and color using the APIs that are applicable to all light types. Now let's set the APIs that are specific to a Rect light, its Height and Width:
```python
rect_light.CreateHeightAttr(100)    
rect_light.CreateWidthAttr(100) 
```
{ref}`figure-4-3` shows the Rect light we have just created on the Statue stage. Here the Rect Light is being used as a broad illuminator of the subject. Positioned at the front and right of the subject, angled at 45° towards it, and being large causes the light to illuminate most of the front surfaces and cast very soft shadows.

```{figure} ./images/5/image9.png
:label: figure-4-3
:alt: rect light
:align: center
:width: 50%

The Rect light on the stage, as viewed in USD Composer. Being positioned 45° in front of the subject allows this light to reach most of the front surfaces. As it is large the shadows created are very soft.
```

#### Disk Light
Like the Rect light, the Disk light provide a wide, even source of light, making it ideal for illuminating large areas or workspaces, and their 2D form makes them easy to position close to other objects, for example, you might place one at the end of a flashlight model or up against a ceiling to represent a recessed LED light. They only emit light from one surface and as a disc light is 2D, you can only set its radius. Let’s add on to the stage:
```python
disk_light = UsdLux.DiskLight.Define(stage, "/World/Lights/DiskLight")   
disk_light.CreateRadiusAttr(50)  
```
You can add translate, rotation, color, and intensity to the light as usual:
```python
disk_light.AddTranslateOp().Set(Gf.Vec3d(0, 200, 0))
disk_light.AddRotateXYZOp().Set(Gf.Vec3d(-90, 0.0, 0))

disk_light.CreateColorAttr(Gf.Vec3f(1, 1, 1))
disk_light.CreateIntensityAttr(30000)
```
{ref}`figure-4-4` shows the Disc light we have just created on the Statue stage. Positioned directly above the subject and having a radius wider than the statue, this Disc light is highlighting the upper surfaces of the statue and revealing slightly more of its form than the Cylinder light. Having a radius larger than the subject causes it to cast soft shadows.
```{figure} ./images/5/image19.png
:label: figure-4-4
:alt: disk light
:align: center
:width: 50%

The Disc light on the stage, as viewed in USD Composer. Positioned above the subject, and being wider than it, this light highlights the upper surfaces and casts soft shadows.
```

#### Sphere Light
As the name suggests, a sphere light is spherical in shape, distributing light evenly in all directions. A sphere light emits light in all directions, most closely resembling a bulb or other omnidirectional light source. You can specify the radius of the sphere.

```python
sphere_light = UsdLux.SphereLight.Define(stage, "/World/Lights/SphereLight")    

sphere_light.CreateRadiusAttr(5.0)    

sphere_light.AddTranslateOp().Set(Gf.Vec3d(-22, 166, 66))

sphere_light.CreateColorAttr(Gf.Vec3f(1, 1, 1))
sphere_light.CreateIntensityAttr(400000)

```
While a sphere light emits light in all directions, it can be approximated as a point light source for many practical purposes, especially when the sphere's diameter is much smaller than the objects being illuminated or it is far away. Treating it as a point light helps simplify calculations, easing the burden on renderers, and making it more suitable for hardware-constrained environments, such as mobile devices or virtual reality systems. To turn you sphere light into a `point light`:

```python
sphere_light.CreateTreatAsPointAttr(True)
```

In its current form this light will not import well into Blender. This is due to the way Blender calculates the intensity of a point source light, which results in a much lower intensity. If you are using Blender as your viewer, then you should return the sphere to its full 3D state with:
```python
sphere_light.CreateTreatAsPointAttr(False)
```

{ref}`figure-4-5` shows the Sphere light we have just created on the Statue stage. Being relatively small and positioned close to the statue’s head and shoulder, this light is used here to accentuate those areas of the subject. Also, it provides point highlights on many other areas, which is a useful way to accentuate the reflectivity of a material. The larger the radius of the sphere, the softer its shadows will become, with a point light source giving very hard shadows.



(three-point-lighting)=
### 5.2.3 Three-Point Lighting

## Summary
```{figure} ./images/4/image13.png
:label: figure-4-x
:alt: xform comp
:align: center
:width: 80%

The three key elements that make up a transform (Xform): translate (location), rotation (orientation), and scale (size).
```

```{code} python
:label: code-3-1
:caption: Add internal reference

def internal_reference(prim: Usd.Prim, ref_target_path: Sdf.Path):    
    references: Usd.References = prim.GetReferences()
    references.AddInternalReference(
        primPath=ref_target_path
     ) 
```

:::{table}  A Comparison of Tools for Viewing and Scripting with OpenUSD
:name: legacy-config-files
:lable: table-1

:::